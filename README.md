Sebastian Cojocariu 321CB UPB ACS					

				                                        
                                                  Exploit Vulnerabilities



Observatie:In cele ce urmeaza argumentele sunt indexate in ordinea fireasca din C.

Functii folosite pe parcurs:

0x08048530(top stiva) : nu primeste niciun argument si returneaza in ebx pe [esp](adica adresa de return a functiei).La iesire,
esp=esp-4.

0x080485EB (400SumString):Primeste ca parametru o adresa de memorie.Foloseste 2 variabile locale,prima initializata cu 0 folosita pe post
de contor al for-ului de la i=0,399,iar a 2-a va fi folosita pentru a retine suma primelor 400 caractere.La sfarsit,daca suma e ==12345h
atunci al=1 si eax devine 0001(unde fiecare cifra e reprezentata pe 1 octet),altfel al = 0 si eax = 0000.Pe scurt,functia verifica daca
suma primelor 400 de caractere e 1 si returneaza rezultatul in eax.


-----------------------------------------------------Functii de deblocare Vault ------------------------------------

Zonele de memorie care trebuie initializate cu 0 : dword[0x0804A2DC],dword[0x0804A2E0] sau dword[0x0804A2E4]

0x8048895 (FunctieInitializare1Variabila): Nu primeste argumente :initializeaza cu 0 dword[0x0804A2DC].

0x080488BA (FunctieInitializare2Variabila) :Primeste un argument:initializeaza cu 0 dword[0x0804A2E0] doar daca
argumentul e egal cu 0xdeadc0de.

0x080488EA (FunctieInitializare3Variabila): Primeste 2 argumente:aloca 2 variabile locale , in prima este stocata suma celor 2 argumente,
iar in al doilea diferenta lor.Se verifica daca suma lor este 0xdeadbeef , respectiv diferenta lor este 0x13371337.In caz afirmativ
se face  mov dword[0x0804A2E4],0.


--------------------------------------------------------------Start------------------------------------------------

0x080489A9(FunctieStart):aici incepe executabilul.Se apeleaza setbuf si mmap.Se afiseaza folosind functia XorAA "bordura"
cu "Welcome to the vault.Unlock it if you can".Se intra intr-o bucla (0x08048A0E) care afiseaza optiunile disponibile 
(0x0804883,FunctieAfisareOptiuni) dupa care se intra in Main.Se repeta procedeul pana cand din Main se alege optiunea 5 
sau se intampla un seg fault ca urmare a unui exploit.

0x0804883(FunctieAfisareOptiuni):Afiseaza meniul cu optiuni.

0x08048871(FunctieAfisareBordura):Afiseaza "Welcome to the vault.Unlock it if you can".


--------------------------------------------------------------Main------------------------------------------------
Aloca pe stiva o variabila locala de 4 octeti in care va pune rezultatul citirii cu scanf avand drept unul din argumente "%1d" ce
specifica citirea unei singure cifre din intreg(pentru a nu exista vulnerabilitatea de a citi mai mult si a suprascrie adresa de
return,etc).Aici se va scrie numarul optiunii alese,iar daca optiunea e intre 0 si 4 se va face salt la una din adresele de mai sus,
iar in caz contrar se va afisa mesajul "Unknown option"(0x08048E1) dupa care se va dupa la iesirea din main.
(si va intra inapoi in bucla 0x08048A0E).


-------------------------------------------------------------Optiuni----------------------------------------------


0X08048679 (Optiune0):Aloca o variabla locala de 20h=32 biti pe stiva pe care ii initializeaza cu 0(prin ecx).
Se face push 0x08048D80(adresa mesajului "Enter the valid serial:") si se apeleaza puts dupa care restaureaza 
stiva (stergem parametri);se apeleaza scanf cu "%32s" ce va scrie primul string de pana in 32 de caractere oferite la intrare 
in variabila locala.Se apeleaza functia 0x08048A5D (EcuatieTask0).Daca serial key-ul este corect eax 
va fi 1,altfel 0.Se verifica cu test acest lucru,iar in cazul in care e corect se afiseaza mesajul 
"Correct"(altfel "Nope,try again").Functia va apela EcuatieTask0 care poate fi examintata in gdb , deci se poate 
construi pas cu pas serial key-ul valid,fapt care constituie o vulnerabilitate.Deasemenea, se formeaza si un buffer overflow
daca se introduc mai mult de 32 de biti.
---------------------------------------------------------Functii Task0 -----------------------------------------

0x08042A20(Initializare0):functie care initializeaza cu 0 registrii ah,ecx,edx,esi(nu are parametri).

0x08048A29(AsciiConverter):parametrul e dat prin registrul dl.Daca dl='0','1',...'9','a','b',...,'f' atunci el va fi inlocuit cu valoarea
sa ca byte in baza 16('0'->0...'a'->10),...'f'->15).Orice litera mare,anume 'A',...,'Z' este lasata neschimbata.Orice alt caracter diferit 
de acestea va genera eax=0;

0x08048A52(ZFChecker):primeste toate flags ca parametri (pushf)si verifica daca ZF=0,caz in care face eax=0
(verifica ZF ultimei operatii care l-a modificat).Altfel nu face nimic. 

0x08048A5D(EcuatieTask0):Functie care primeste adresa unui string si verifica daca primele 24 de litere au anumite proprietati,prin
apelari succesive de Initializare0 ,AsciiConverter,respectiv ZFChecker.(proprietati de genul :3 charuri consecutive din string 
respecta un sistem de 3 ecuatii cu cate 2 necunoscute fiecare,se shifteaza un char si la stanga si la dr cu 4 biti si stim
cat se optine in urma fiecarui,caz in care trebuie sa reconstituim char-ul,2 charuri consecutive sunt date functiei AsciiConverter,dupa
care stim suma celor 2 rezultate si cat e ultimul rezultat si trebuie sa reconstituim charurile,etc).Stiind acest lucru,construim 
payload-ul prin rezolvarea acestor ecuatii.

-------------------------------------------------------------------------------------------------------------

0x080486EA (Optiune1):Se aloca o variabila locala de 14h=20 biti,se afiseaza mesajul "Enter desired username:",dupa care se scrie in variabila locala stringul dat la intrare.
(cu mentiunea ca scanf primeste "%20s",deci va citi pana la 20 de caractere si nu se va putea suprascrie nicio adresa de return sau ebp,deci nu e vulnerabilitate).
Totusi e un bug pentru ca daca se introduc mai mult de 20 de litere programul se creeaza un buffer overflow care duce la seg fault.

0x08048710 (Optiune2):Se aloca o variabila locala de 10h=16 biti,se afiseaza mesajul "Enter desired address:",dupa care se scrie in variabila locala stringul dat la intrare.
(cu mentiunea ca scanf primeste "%20s",deci va citi pana la 20 de caractere pe care le va scrie in variabila locala,deci mai mult decat e alocat pentru buffer si va putea 
suprascrie vechiul ebp ,fiind o vulnerabilitate).Daca se introduc mai multe se creeaza un buffer overflow ce duce la seg fault.

0x08048736 (Optiune3):Aloca o variabila locala pe stiva (imediat sub ebp) si apeleaza read cu fildes=0(pt intrarea standard),adresa ebp-4,18h=24biti (va citi fix 24 de biti,deci
nu este cazul de buffer overflow ,pe care ii va scrie la adresa ebp-4,deci va putea suprascrie [ebp-4],vechiul ebp,adresa de return a functiei si inca 12 biti de "deasupra lor",
reprezentand o vulnerabilitate dupa cum se va vedea in exemplele de la task2 si task3:Pentru a debloca vault se va vor da 3 payload-uri continue care vor suprascriere la 
fiecare pas adresa de ret si ebp din functia Optiune3 cu cele 3 functii care modifica variabilele dword[0x0804A2DC],dword[0x0804A2E0] sau dword[0x0804A2E4]).

0x0804874E (Optiunea4):Aloca pe stiva un buffer(variabila locala) de 404h=1028biti.Verifica daca cel putin unul dintre dword[0x0804A2DC],dword[0x0804A2E0] 
sau dword[0x0804A2E4] este diferit de 0,caz in care se va afisa "Vault is still locked"(0x008048DEE).In caz contrar(toate sunt egale cu 0) se sare la adresa 0x0804877E.
Aici se vor citi de la intrare 400h=1024 biti care vor fi scrisi de la ebp-401h si pana la ebp-2.Se aplica functia XorAA pentru adresa 0x0804A4A8 cu strlen=400h.
Se verifica cu functia 400SumString daca stringul de la ebp-401h are suma primelor 1024 caractere egala cu 12345h.In caz afirmativ se sare la adresa 0x080487C0 unde 
se va verifica daca stringul contine secventa "Sebastian".In caz afirmativ se sare la adresa 0x080487DA unde se va verifica daca stringul contine secventa "Cojocariu".
In caz afirmativ se apeleaza mprotect pentru adresa 0x0804A4A8,cu strlen=400h si permisiune=5(drept de scriere si executie).Dupa aceasta se face push ebp-401h si call eax 
,unde eax contine adresa spre functia la care pointeaza 0x0804A4A8,anume 0xb7fd4000.(functie care e pe heap si se poate vedea folosind versiunea peda din gdb).Aceasta functie 
aloca o variabila locala de 3e8h=1000 biti,introduce in edi,esp(cel din functie) si in esi,ebp-401h(unicul parametru al acestei functii) si scrie folosind ecx=1024 si rep movs 
in variabila locala 1024 biti din stringul initial(cel obtinut dupa ce s-au facut diferite de 0 cele 3 variabile si saltul la 0x0804877E,cand s-a apelat read).
Tinand cont ca pentru ea s-au alocat doar 1000 biti,ea va ajunge sa suprascrie si urmatorii 24 biti(vechiul ebp dinainte de saltul in functie,adresa de return
si inca 16 biti,conform cu continutul stringului respectiv)(asadar e o vulnerabilitate,dupa cum se va vedea in rezolvarea task3).

0x08048985 (Optiunea 5):Se afiseaza mesajul "Bye" si se apeleaza exit(se iese din program).



--------------------------------------------------------------------------------Descriere Task2 ------------------------------------------------------------


Vulnerabilitati: Optiune0 (datorita functiei de verificare EcuatieTask0),Optiune2(poate suprascrie vechiul ebp),Optiune3 si 0xb7fd4000(SuprascriereStiva) din task4
Bugs: Optiune0,Optiune1(buffer overflow)
A se vedea explicatiile detaliate din cadrul acestor functii.





--------------------------------------------------------------------------------Descriere Task 3--------------------------------------------------------


Am observat ca Optiunea3 foloseste un buffer incepand de la ebp-4 in care se citeste cu read 24 de caractere,deci cu un payload de 4 ajungem la ebp vechi.
Totodata,pentru a afisa "Win" trebuia sa intram in Optiunea4,lucru care duce la afisarea "Vault is still locked".Pentru a debloca vault-ul am observat ca e 
nevoie ca dword[0x0804A2DC],dword[0x0804A2E0] sau dword[0x0804A2E4] sa fie initializate la 0.Cautand direct in codul dezasamblat(Ida nu le vedea) am descoperit 
3 functii care setau aceste variabile la 0,daca se respectau anumite conditii(conditiile sunt cele de la sectiunea -Functii de deblocare Vault-).Am rezolvat
ecuatiile aferente pentru a putea gasi argumentele bune care sa duca la initializarea acelor zone.Am creeat 3 payload-uri de forma "3\naaaa....aaaa\n" unde
secventa de aaa...aaa e in nr de 24 si respecta conditiile pentru ca functiile sa ajunga la initializarea cu 0.(a se vedea in gen_payload.py).Aceste payload-uri
au fost "concatenate" dupa care s-a introdus si "4\n" aferenta Optiunii4.Din moment ce vault-ul a fost deblocat,s-a facut jump la 0x0804877E.Am observat ca se
apeleaza read(care primeste 400h ca parametru),ceea ce duce la stocare in ebp-401h a 400h caractere citite.Am remarcat imediat ca pentru a inainta trebuie ca
suma celor 400 de caractere trebuie sa fie egala cu 12345h,iar ulterior ca ele trebuie sa contina si secventele "Sebastian",respectiv "Cojocariu".Am construit
un payload aferent ("SebastianCojocariu" urmat de combinatii de 'H' si 'I'),pana am ajuns la call protect(aici se aloca drepturi scriere si executie pentru zona
de memorie spre care pointeaza 0x0804A4A8,anume 0xb7fd4000),se face push edx(=ebp-401h=adresa stringului citit) si se apeleaza call eax(care a fost initializat
anterior cu 0x0804A4A8).Se sare la functia 0xb7fd4000(FunctieSuprascriereStiva).Aceasta functie aloca o variabila locala de 3e8h=1000 biti,introduce in edi,esp
(cel din functie) si in esi,ebp-401h(unicul parametru al acestei functii) si scrie folosind ecx=1024 si rep movs in variabila locala 1024 biti din stringul initial
(cel obtinut dupa ce s-au facut diferite de 0 cele 3 variabile si saltul la 0x0804877E,cand s-a apelat read).Tinand cont ca pentru ea s-au alocat doar 1000 biti,
ea va ajunge sa suprascrie si urmatorii 24 biti (vechiul ebp dinainte de saltul in functie,adresa de return si inca 16 biti,conform cu continutul stringului respectiv).
Am inspectat zona de memorie la care se gaseste mesajul "Win"(0x08048E05) si am observat ca exista o functie la adresa 0x0804882b(FunctieWin):aici se fac o serie de 
operatii dword[0x0804A4A8],dupa care se verifica daca rezultatul e egal cu dword[0x0804A2F8].Initial am dat un payload astfel incat sa sara in FunctiaWin
(am suprascris adresa de return cu adresa FunctiaWIN) ,chiar la cmp ,am verificat cat e dword[0x0804A4A8] si am constatat ca e 0xba208000.
Am construit un shellcode de tipul ("mov dword[0x0804A2F8],0xba208000\ncall ret\n") pe care l-am scris in cod masina(10 biti).Intrucat singurul loc de suprascriere 
era de la esp+1000 pana la esp+1024,insa mai trebuia sa scriu inca 4 adrese de return,"deasupra" lui ebp nu era o optiune,asa ca am scris cei 10 biti chiar sub ebp
,de la ebp-12.In final ,am gasit payload-ul final ce se poate vedea in gen_payload.py.Acesta face salt mai intai la adresa de pe stiva unde e scris shell codul,
executa codul si dupa ce da de ret sare la functia de comparare(in care deja dword[0x0804A2F8] a fost initializat cu 0xba208000).Aici ajunge sa printeze mesajul 
de win si sare la exit-ul din Optiune5.






